{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <ul> <li>docker</li> <li>kubernetes</li> </ul>"},{"location":"DSA/Arrays/Dutch_Flag_Algorithm/","title":"Dutch National Flag Algorithm","text":""},{"location":"DSA/Arrays/Dutch_Flag_Algorithm/#introduction","title":"Introduction","text":"<p>The Dutch National Flag Algorithm is used to sort an array with three distinct elements efficiently. It is commonly applied to problems involving sorting 0s, 1s, and 2s.</p> <ul> <li>Works in O(N) time with O(1) extra space.</li> <li>Uses three pointers: <code>low</code>, <code>mid</code>, and <code>high</code>.</li> </ul> <p>https://leetcode.com/problems/sort-colors/description/</p>"},{"location":"DSA/Arrays/Dutch_Flag_Algorithm/#problem-statement","title":"Problem Statement","text":"<p>Given an array containing only 0s, 1s, and 2s, sort it in-place without using extra space.</p>"},{"location":"DSA/Arrays/Dutch_Flag_Algorithm/#example","title":"Example:","text":""},{"location":"DSA/Arrays/Dutch_Flag_Algorithm/#input","title":"Input:","text":"<p><code>[2, 0, 1, 2, 0, 1]</code></p>"},{"location":"DSA/Arrays/Dutch_Flag_Algorithm/#output","title":"Output:","text":"<p><code>[0, 0, 1, 1, 2, 2]</code></p>"},{"location":"DSA/Arrays/Dutch_Flag_Algorithm/#algorithm-explanation","title":"Algorithm Explanation","text":"<ol> <li>Initialize three pointers:</li> <li><code>low</code> \u2192 0 (Boundary for 0s)</li> <li><code>mid</code> \u2192 0 (Current element being examined)</li> <li> <p><code>high</code> \u2192 last index (Boundary for 2s)</p> </li> <li> <p>Traverse the array while <code>mid \u2264 high</code>:</p> </li> <li>If <code>arr[mid] == 0</code>:  <ul> <li>Swap <code>arr[low]</code> and <code>arr[mid]</code></li> <li>Increment <code>low</code> and <code>mid</code></li> </ul> </li> <li>If <code>arr[mid] == 1</code>:  <ul> <li>Move <code>mid</code> forward</li> </ul> </li> <li>If <code>arr[mid] == 2</code>:  <ul> <li>Swap <code>arr[mid]</code> and <code>arr[high]</code></li> <li>Decrement <code>high</code></li> </ul> </li> </ol>"},{"location":"DSA/Arrays/Dutch_Flag_Algorithm/#code-implementation","title":"Code Implementation","text":""},{"location":"DSA/Arrays/Dutch_Flag_Algorithm/#java-implementation","title":"Java Implementation","text":"<p>```java public class DutchFlag {     public static void sortColors(int[] arr) {         int low = 0, mid = 0, high = arr.length - 1;</p> <pre><code>    while (mid &lt;= high) {\n        if (arr[mid] == 0) {\n            swap(arr, low++, mid++);\n        } else if (arr[mid] == 1) {\n            mid++;\n        } else {\n            swap(arr, mid, high--);\n        }\n    }\n}\n\nprivate static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\npublic static void main(String[] args) {\n    int[] arr = {2, 0, 2, 1, 1, 0};\n    sortColors(arr);\n    System.out.println(Arrays.toString(arr)); // Output: [0, 0, 1, 1, 2, 2]\n}\n</code></pre> <p>}</p>"},{"location":"DSA/Arrays/KadanesAlgorithm/","title":"Kadane's Algorithm","text":"<p>Kadane's Algorithm is an efficient way to solve the Maximum Subarray Problem. The problem asks you to find the contiguous subarray within a one-dimensional array of numbers which has the largest sum.</p>"},{"location":"DSA/Arrays/KadanesAlgorithm/#problem-definition","title":"Problem Definition:","text":"<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return that sum.</p>"},{"location":"DSA/Arrays/KadanesAlgorithm/#example","title":"Example:","text":"<p>For the array: <code>[\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4]</code></p> <ul> <li>The contiguous subarray <code>[4, \u22121, 2, 1]</code> has the largest sum = <code>6</code>.</li> </ul>"},{"location":"DSA/Arrays/KadanesAlgorithm/#kadanes-algorithm_1","title":"Kadane\u2019s Algorithm:","text":"<p>The key idea behind Kadane's Algorithm is to maintain two variables: 1. <code>current_max</code>: The maximum sum of the subarray ending at the current index. 2. <code>global_max</code>: The maximum sum found so far across any subarray.</p>"},{"location":"DSA/Arrays/KadanesAlgorithm/#algorithm-steps","title":"Algorithm Steps:","text":"<ol> <li>Initialize two variables:  </li> <li><code>current_max = nums[0]</code> </li> <li> <p><code>global_max = nums[0]</code></p> </li> <li> <p>Traverse through the array starting from the second element:</p> </li> <li> <p>Update <code>current_max</code> as the maximum of:</p> <ul> <li><code>nums[i]</code> (start a new subarray)  </li> <li><code>current_max + nums[i]</code> (extend the existing subarray)</li> </ul> </li> <li> <p>Update <code>global_max</code> if <code>current_max</code> is larger than <code>global_max</code>.</p> </li> <li> <p>The <code>global_max</code> will contain the maximum sum of the subarray by the end of the iteration.</p> </li> </ol>"},{"location":"DSA/Arrays/KadanesAlgorithm/#code-implementation","title":"Code Implementation:","text":"<p>```java class Solution {     public int maxSubArray(int[] nums) {         int current_max = nums[0]; // Initialize with the first element         int global_max = nums[0];  // Initialize with the first element</p> <pre><code>    // Traverse the array starting from the second element\n    for (int i = 1; i &lt; nums.length; i++) {\n        current_max+= nums[0];\n\n        global_max = Math.max(global_max, current_max);  // Update global max if needed\n\n        if(current_max&lt; 0) current_max = 0; \n    }\n\n    return global_max;\n}\n</code></pre> <p>}</p>"},{"location":"DSA/Arrays/KadanesAlgorithm/#what-if-we-need-to-track-the-subarray","title":"what if we need to track the subarray","text":"<pre><code>- whenever there is a sum with zero , we call it s starting\n- whenever the sum is greater than the max , we call it an ending\n</code></pre>"},{"location":"DSA/Arrays/MajorityElementArray/","title":"MajorityElementArray","text":"<p>-[Majority Problem][https://leetcode.com/problems/majority-element/submissions/1593232264/]</p>"},{"location":"DSA/Arrays/MajorityElementArray/#boyer-moore-voting-algorithm","title":"Boyer-Moore Voting Algorithm","text":"<p>The Boyer-Moore Voting Algorithm is an optimal algorithm for finding the majority element in an array. The majority element is defined as the element that appears more than \u230an / 2\u230b times in the array.</p>"},{"location":"DSA/Arrays/MajorityElementArray/#key-concepts","title":"Key Concepts:","text":"<ul> <li>Candidate Element: The element that could potentially be the majority element.</li> <li>Count: The vote count for the current candidate element.</li> </ul>"},{"location":"DSA/Arrays/MajorityElementArray/#algorithm-overview","title":"Algorithm Overview:","text":"<ol> <li>Start with the first element as the candidate and set the count to 1.</li> <li>Traverse through the array, comparing each element with the current candidate:<ul> <li>If the current element is the same as the candidate, increase the count.</li> <li>If the current element is different from the candidate, decrease the count.</li> </ul> </li> <li>If the count reaches zero, change the candidate to the current element and reset the count to 1.</li> <li>At the end of the traversal, the candidate will be the majority element (since it's guaranteed to exist by the problem's constraints).</li> </ol>"},{"location":"DSA/Arrays/MajorityElementArray/#code-implementation","title":"Code Implementation:","text":"<p>```java class Solution {     public int majorityElement(int[] nums) {         int count = 1;         int element = nums[0];</p> <pre><code>    for (int i = 1; i &lt; nums.length; i++) {\n        if (nums[i] == element)\n            count++;\n        else\n            count--;\n\n        if (count == 0) {\n            element = nums[i];\n            count = 1;  // Reset count since we switched the candidate\n        }\n    }\n\n    return element;\n}\n</code></pre> <p>}</p>"},{"location":"DSA/Arrays/NextPermutation/","title":"Next Permutation Problem","text":""},{"location":"DSA/Arrays/NextPermutation/#problem-statement","title":"\ud83d\udccc Problem Statement","text":"<p>Given an integer array <code>nums</code>, find the next lexicographically greater permutation of numbers. If no such permutation exists, rearrange <code>nums</code> into the smallest possible order (sorted in ascending order).</p> <p>You must modify the input array in place without using extra memory.</p>"},{"location":"DSA/Arrays/NextPermutation/#approach-optimal-solution","title":"\ud83d\ude80 Approach (Optimal Solution)","text":"<p>The goal is to generate the next permutation efficiently in O(n) time complexity.</p>"},{"location":"DSA/Arrays/NextPermutation/#steps-to-solve","title":"\ud83d\udd39 Steps to Solve","text":""},{"location":"DSA/Arrays/NextPermutation/#1-find-the-breakpoint","title":"1\ufe0f\u20e3 Find the Breakpoint","text":"<ul> <li>Traverse the array from right to left and find the first index <code>i</code> where <code>nums[i] &lt; nums[i+1]</code>.</li> <li>This breakpoint is the position where rearrangement is needed.</li> <li>If no such index exists, the array is the last permutation, so we reverse it to get the first permutation.</li> </ul>"},{"location":"DSA/Arrays/NextPermutation/#2-find-the-right-swap-candidate","title":"2\ufe0f\u20e3 Find the Right Swap Candidate","text":"<ul> <li>Again, traverse from right to left and find the smallest number larger than <code>nums[breakpoint]</code>.</li> <li>Swap this number with <code>nums[breakpoint]</code>.</li> </ul>"},{"location":"DSA/Arrays/NextPermutation/#3-reverse-the-suffix","title":"3\ufe0f\u20e3 Reverse the Suffix","text":"<ul> <li>Reverse the portion of the array after the breakpoint (<code>breakpoint+1</code> to <code>end</code>) to get the smallest lexicographical order.</li> </ul>"},{"location":"DSA/Arrays/NextPermutation/#final-code-java","title":"\u2705 Final Code (Java)","text":"<pre><code>class Solution {\n    public void nextPermutation(int[] nums) {\n        int breakpoint = -1;\n\n        if (nums.length == 1) return;\n\n        // Step 1: Find the rightmost breakpoint where nums[i] &lt; nums[i+1]\n        for (int i = nums.length - 2; i &gt;= 0; i--) {\n            if (nums[i] &lt; nums[i + 1]) {\n                breakpoint = i;\n                break;\n            }\n        }\n\n        // If no breakpoint, reverse the entire array (last permutation case)\n        if (breakpoint == -1) {\n            reverse(nums, 0, nums.length - 1);\n            return;\n        }\n\n        // Step 2: Find the smallest element larger than nums[breakpoint] to swap\n        for (int i = nums.length - 1; i &gt; breakpoint; i--) {\n            if (nums[i] &gt; nums[breakpoint]) {\n                // Swap and break immediately\n                int temp = nums[i];\n                nums[i] = nums[breakpoint];\n                nums[breakpoint] = temp;\n                break;\n            }\n        }\n\n        // Step 3: Reverse the suffix after the breakpoint to get the next permutation\n        reverse(nums, breakpoint + 1, nums.length - 1);\n    }\n\n    public void reverse(int[] nums, int start, int end) {\n        while (start &lt; end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n</code></pre>"},{"location":"DSA/Arrays/NextPermutation/#dry-run-example","title":"\ud83d\udee0 Dry Run Example","text":""},{"location":"DSA/Arrays/NextPermutation/#example-1","title":"Example 1","text":""},{"location":"DSA/Arrays/NextPermutation/#input","title":"Input:","text":"<pre><code>int[] nums = {1,2,3};\n</code></pre>"},{"location":"DSA/Arrays/NextPermutation/#execution","title":"Execution:","text":"<ul> <li>Breakpoint at index <code>1</code> (<code>nums[1] = 2</code>) since <code>2 &lt; 3</code>.</li> <li>Swap <code>2</code> with <code>3</code> \u2192 <code>{1,3,2}</code>.</li> <li>Reverse after index <code>1</code> (no change needed).</li> </ul>"},{"location":"DSA/Arrays/NextPermutation/#output","title":"Output:","text":"<pre><code>[1,3,2]\n</code></pre>"},{"location":"DSA/Arrays/NextPermutation/#example-2","title":"Example 2","text":""},{"location":"DSA/Arrays/NextPermutation/#input_1","title":"Input:","text":"<pre><code>int[] nums = {3,2,1};\n</code></pre>"},{"location":"DSA/Arrays/NextPermutation/#execution_1","title":"Execution:","text":"<ul> <li>No breakpoint found (descending order).</li> <li>Reverse the array \u2192 <code>{1,2,3}</code>.</li> </ul>"},{"location":"DSA/Arrays/NextPermutation/#output_1","title":"Output:","text":"<pre><code>[1,2,3]\n</code></pre>"},{"location":"DSA/Arrays/NextPermutation/#time-complexity-analysis","title":"\u23f3 Time Complexity Analysis","text":"<ul> <li>Finding the breakpoint: <code>O(n)</code></li> <li>Finding the rightmost greater element to swap: <code>O(n)</code></li> <li>Reversing the suffix: <code>O(n)</code></li> </ul> <p>\ud83d\udd39 Overall Complexity: O(n) + O(n) + O(n) = O(n)</p>"},{"location":"DSA/Arrays/NextPermutation/#key-takeaways","title":"\u26a1 Key Takeaways","text":"<ul> <li>Understanding Breakpoints is key to solving this problem.</li> <li>Reversing the suffix is crucial to ensure the next permutation is lexicographically correct.</li> <li>Edge case handling: If no breakpoint is found, reverse the entire array.</li> </ul> <p>\ud83d\udca1 This approach efficiently finds the next permutation in O(n) time complexity, making it optimal! \ud83d\ude80</p>"},{"location":"Kubernetes/kubernetes/","title":"Kubernetes Notes","text":""},{"location":"Kubernetes/kubernetes/#1-introduction-to-kubernetes","title":"1. Introduction to Kubernetes","text":"<p>Kubernetes is an open-source container orchestration platform that helps in managing containerized applications across multiple nodes.</p>"},{"location":"Kubernetes/kubernetes/#11-types-of-nodes","title":"1.1 Types of Nodes","text":"<ul> <li>Master Node: Manages the cluster and consists of components like:</li> <li><code>kube-apiserver</code></li> <li><code>etcd</code></li> <li><code>controller manager</code></li> <li><code>scheduler</code></li> <li>Worker Node: Runs the actual application workload and consists of:</li> <li><code>kubelet</code></li> <li><code>container runtime</code> (like Docker or containerd)</li> <li><code>kube-proxy</code></li> </ul>"},{"location":"Kubernetes/kubernetes/#12-basic-kubernetes-commands","title":"1.2 Basic Kubernetes Commands","text":"<pre><code>kubectl run nginx --image nginx # Deploy a pod\nkubectl get pods  # Get running pods\nkubectl create -f definition.yaml  # Create resources using YAML files\n</code></pre>"},{"location":"Kubernetes/kubernetes/#2-kubernetes-yaml-file-structure","title":"2. Kubernetes YAML File Structure","text":"<p>A Kubernetes YAML file consists of four top-level fields:</p> <ul> <li>apiVersion: Version of the Kubernetes API.</li> <li>kind: Type of object (Pod, ReplicaSet, Deployment, Service, etc.).</li> <li>metadata: Information about the object (name, labels, etc.).</li> <li>spec: Specification describing the desired state.</li> </ul>"},{"location":"Kubernetes/kubernetes/#21-example-creating-a-pod","title":"2.1 Example: Creating a Pod","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: redis\nspec:\n  containers:\n    - name: redis\n      image: redis\n</code></pre>"},{"location":"Kubernetes/kubernetes/#3-replicaset-and-scaling","title":"3. ReplicaSet and Scaling","text":""},{"location":"Kubernetes/kubernetes/#31-what-is-a-replicaset","title":"3.1 What is a ReplicaSet?","text":"<p>A ReplicaSet ensures that a specified number of pod replicas are running at any given time.</p> <p>Replica set provides us a way to handle the situation whenever a pod in your node fails , using it we can make sure a new pod gets created whenever the pod is down , or suppose you want scaling then replica set gives us a way to add new</p>"},{"location":"Kubernetes/kubernetes/#32-scaling-a-replicaset","title":"3.2 Scaling a ReplicaSet","text":"<p>There are two ways to scale the number of replicas:</p> <pre><code>kubectl replace -f replica-definition.yaml  # Modify the YAML and replace the resource\nkubectl scale --replicas=6 -f replica-definition.yaml  # Scale via CLI\n</code></pre>"},{"location":"Kubernetes/kubernetes/#kubernetes-replicaset-and-pod-example","title":"Kubernetes ReplicaSet and Pod Example","text":""},{"location":"Kubernetes/kubernetes/#pod-definition","title":"Pod Definition","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-app-pod\n  labels:\n    name: my-app\n    type: frontend\nspec:\n  containers:\n    - name: nginx\n      image: nginx\n</code></pre>"},{"location":"Kubernetes/kubernetes/#replicaset-definition","title":"ReplicaSet Definition","text":"<pre><code>apiVersion: apps/v1\nkind: ReplicaSet\nmetadata:\n  name: myapp-replicaset\n  labels:\n    name: my-app\n    type: frontend\nspec:\n  replicas: 3  # How many pods will be created\n  selector:\n    matchLabels:\n      type: frontend  # Selector to manage matching pods\n  template:\n    metadata:\n      name: my-app-pod\n      labels:\n        name: my-app\n        type: frontend\n    spec:\n      containers:\n        - name: nginx\n          image: nginx\n</code></pre>"},{"location":"Kubernetes/kubernetes/#explanation","title":"Explanation","text":""},{"location":"Kubernetes/kubernetes/#pod-definition_1","title":"Pod Definition","text":"<ul> <li>Creates a standalone Pod named <code>my-app-pod</code>.</li> <li>Uses labels name: my-app and type: frontend.</li> <li>Runs an nginx container.</li> </ul>"},{"location":"Kubernetes/kubernetes/#replicaset-definition_1","title":"ReplicaSet Definition","text":"<ul> <li>Manages 3 replicas of Pods.</li> <li>Uses matchLabels to control which Pods it manages.</li> <li>The template inside the ReplicaSet defines the Pod structure (same as above).</li> </ul>"},{"location":"Kubernetes/kubernetes/#commands-to-deploy","title":"Commands to Deploy","text":"<ol> <li>Apply the Pod definition (if running standalone):</li> </ol> <p><code>sh    kubectl apply -f pod.yaml</code></p> <ol> <li>Apply the ReplicaSet definition:</li> </ol> <p><code>sh    kubectl apply -f replicaset.yaml</code></p> <ol> <li>Check running Pods:</li> </ol> <p><code>sh    kubectl get pods</code></p> <ol> <li>Check ReplicaSet status:</li> </ol> <p><code>sh    kubectl get replicaset</code></p>"},{"location":"Kubernetes/kubernetes/#4-deployments","title":"4. Deployments","text":"<p>A Deployment is a higher-level abstraction that manages ReplicaSets and provides features like rolling updates and rollbacks.</p>"},{"location":"Kubernetes/kubernetes/#41-deployment-yaml-example","title":"4.1 Deployment YAML Example","text":"<pre><code>apiVersion: apps/v1  # API version for Deployments  \nkind: Deployment  # Defines that this is a Deployment object\n\nmetadata:\n  name: httpd-frontend  # Name of the Deployment (This is for Kubernetes reference)\n\nspec:  # Deployment specifications (This controls the Deployment behavior)\n  replicas: 3  # Number of pod replicas to maintain\n\n  selector:  # This is used by Deployment to manage Pods\n    matchLabels:\n      app: httpd-frontend  # This must match the labels in 'template.metadata.labels'\n\n  template:  # This defines the Pod specification (How the Pod should be created)\n    metadata:\n      labels:  # Labels assigned to the Pods created by this Deployment\n        app: httpd-frontend  # This must match 'selector.matchLabels' above\n\n    spec:  # Pod specification (How the Pod should be structured)\n      containers:\n      - name: httpd-container  # Container name inside the Pod\n        image: httpd:2.4-alpine  # The container runs this Docker image\n</code></pre>"},{"location":"Kubernetes/kubernetes/#42-deployment-commands","title":"4.2 Deployment Commands","text":"<pre><code>kubectl create -f deployment.yaml  # Create a deployment\nkubectl apply -f deployment.yaml  # Apply changes to an existing deployment\n</code></pre>"},{"location":"Kubernetes/kubernetes/#43-rollout-and-rollback","title":"4.3 Rollout and Rollback","text":"<pre><code>kubectl rollout status deployment/myapp-deployment  # Check rollout status\nkubectl rollout history deployment/myapp-deployment  # View rollout history\nkubectl rollout undo deployment/deployment_name  # Rollback to previous version\n</code></pre>"},{"location":"Kubernetes/kubernetes/#5-kubernetes-services","title":"5. Kubernetes Services","text":"<p>Kubernetes Services allow communication between different pods or expose them outside the cluster.</p>"},{"location":"Kubernetes/kubernetes/#51-types-of-services","title":"5.1 Types of Services","text":"<ol> <li>NodePort - Exposes a service on a static port on each node.<ul> <li>There are 3 components in the nodeport:</li> <li>Targetport : the port where the pod runs inside the node</li> <li>port: the port of the nodeport //mandatory</li> <li>Nodeport: the port which will be exposed (30000 -&gt; 32000) </li> </ul> </li> <li>ClusterIP - Internal communication within the cluster.</li> <li>LoadBalancer - Exposes service externally using a cloud provider\u2019s load balancer.</li> </ol>"},{"location":"Kubernetes/kubernetes/#52-service-yaml-example-nodeport","title":"5.2 Service YAML Example (NodePort)","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: myapp-service\nspec:\n  type: NodePort\n  ports:\n    - targetPort: 80\n      port: 80\n      nodePort: 30008\n  selector:\n    app: my-app\n    type: frontend\n</code></pre>"},{"location":"Kubernetes/kubernetes/#53-service-yaml-examplecluster-ip","title":"5.3 Service YAML Example(Cluster IP)","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n    name: backend\nspec:\n    type: ClusterIP\n    ports:\n        - TargetPort: 80\n        - port : 80\n    selector:         // this is to select which nodes it'll target along\n        app: my-app\n        type: backend\n</code></pre>"},{"location":"Kubernetes/kubernetes/#53-get-service-details","title":"5.3 Get Service Details","text":"<pre><code>kubectl describe services service-name\nminikube service service-name --url  # Get URL for a service running in Minikube\n</code></pre>"},{"location":"Kubernetes/kubernetes/#6-additional-kubernetes-concepts","title":"6. Additional Kubernetes Concepts","text":""},{"location":"Kubernetes/kubernetes/#61-configmaps","title":"6.1 ConfigMaps","text":"<p>ConfigMaps are used to pass configuration data to containers.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\n\ndata:\n  database_url: mysql://db-user:password@mysql-service/dbname\n</code></pre> <pre><code>kubectl create configmap app-config --from-literal=database_url=mysql://db-user:password@mysql-service/dbname\n</code></pre>"},{"location":"Kubernetes/kubernetes/#62-secrets","title":"6.2 Secrets","text":"<p>Secrets store sensitive information like API keys, passwords, or certificates.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: app-secret\n\ntype: Opaque\ndata:\n  password: cGFzc3dvcmQ=  # Base64 encoded \"password\"\n</code></pre> <pre><code>kubectl create secret generic app-secret --from-literal=password=supersecret\n</code></pre>"},{"location":"Kubernetes/kubernetes/#63-ingress","title":"6.3 Ingress","text":"<p>Ingress is an API object that manages external access to services.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-ingress\nspec:\n  rules:\n  - host: myapp.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: myapp-service\n            port:\n              number: 80\n</code></pre> <pre><code>kubectl apply -f ingress.yaml\nkubectl get ingress\n</code></pre>"},{"location":"Kubernetes/kubernetes/#64-statefulsets","title":"6.4 StatefulSets","text":"<p>Used for stateful applications like databases where each pod needs a unique identity.</p> <pre><code>apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: mysql\nspec:\n  serviceName: \"mysql\"\n  replicas: 3\n  selector:\n    matchLabels:\n      app: mysql\n  template:\n    metadata:\n      labels:\n        app: mysql\n    spec:\n      containers:\n      - name: mysql\n        image: mysql:5.7\n</code></pre> <pre><code>kubectl apply -f statefulset.yaml\nkubectl get statefulset\n</code></pre>"},{"location":"Kubernetes/kubernetes/#7-summary","title":"7. Summary","text":"<ul> <li>Pods are the smallest deployable unit in Kubernetes.</li> <li>ReplicaSets ensure a certain number of pods are always running.</li> <li>Deployments manage ReplicaSets and enable rollouts/rollbacks.</li> <li>Services expose pods internally or externally.</li> <li>ConfigMaps and Secrets manage configuration and sensitive data.</li> <li>Ingress provides HTTP and HTTPS routing.</li> <li>StatefulSets manage stateful applications like databases.</li> </ul> <p>This covers essential Kubernetes concepts and additional missing ones for better understanding. \ud83d\ude80</p>"},{"location":"docker/Docker/","title":"Docker","text":""},{"location":"docker/Docker/#welcome-to-the-docker-home-page","title":"Welcome to the docker Home Page","text":""}]}